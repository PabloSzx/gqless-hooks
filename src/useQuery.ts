import { Client, ObjectNode } from 'gqless';
import { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';

import {
  CommonHookOptions,
  CreateOptions,
  defaultEmptyObject,
  FetchPolicy,
  IState,
  IStateReducer,
  IVariables,
  logDevErrors,
  Maybe,
  SharedCache,
  StateReducer,
  StateReducerInitialState,
  stringifyIfNeeded,
  useFetchCallback,
  CacheSubscribeFn,
  SubscriberHookFn,
} from './common';

/**
 * Query function, it receives the query schema from
 * **gqless** and the variables, if any.
 *
 * It should return the **data** expected from the hook.
 */
export type QueryFn<Query, TData, TVariables extends IVariables> = (
  /**
   * Schema generated by **gqless**
   */
  schema: Client<Query>['query'],
  /**
   * Optional variables to receive and use
   */
  variables: TVariables
) => TData;

/**
 * Query callback arguments
 */
interface QueryCallbackArgs<Query, TData, TVariables extends IVariables> {
  /**
   * Function override of the initial query schema function
   */
  query?: QueryFn<Query, TData, TVariables>;
  /**
   * fetchPolicy to override the policy given in the hook itself.
   */
  fetchPolicy?: FetchPolicy;
  /**
   * Variables to be used instead of the specified in the hook.
   */
  variables?: TVariables;
}

/**
 * Fully featured hook callback
 */
type QueryCallback<TData, Query, TVariables extends IVariables> = (
  queryArgs?: QueryCallbackArgs<Query, TData, TVariables>
) => Promise<Maybe<TData>>;

/**
 * Shorthand query callback args
 */
interface QueryQuickCallbackArgs<TVariables extends IVariables> {
  /**
   * Variables to specify if needed
   */
  variables?: TVariables;
}

/**
 * Shorthand hook callback, only **variables** to specify
 */
type QueryQuickCallback<TData, TVariables extends IVariables> = (
  queryArgs?: QueryQuickCallbackArgs<TVariables>
) => Promise<Maybe<TData>>;

const defaultOptions = <TData, TVariables extends IVariables>(
  options: QueryOptions<TData, TVariables>
) => {
  const {
    lazy = false,
    fetchPolicy = options.lazy ? 'cache-and-network' : 'cache-first',
    fetchTimeout = 10000,
    pollInterval = 0,
    ...rest
  } = options;
  return {
    lazy,
    fetchPolicy,
    fetchTimeout,
    pollInterval,
    ...rest,
  };
};

/**
 * **useQuery** helpers returned from hook
 */
interface UseQueryHelpers<Query, TData, TVariables extends IVariables> {
  /**
   * Query callback using **cache-and-network** fetchPolicy.
   */
  refetch: QueryQuickCallback<TData, TVariables>;
  /**
   * Query callback using **cache-only** fetchPolicy.
   */
  cacheRefetch: QueryQuickCallback<TData, TVariables>;
  /**
   * Generic query callback.
   */
  callback: QueryCallback<TData, Query, TVariables>;
  /**
   * *Vanilla* **gqless** Client query.
   */
  query: Query;
}

/**
 * **useQuery** hook
 */
export type UseQuery<Query> = <TData, TVariables extends IVariables>(
  /**
   * Query function, it should return the data expected from the mutation
   */
  queryFn: QueryFn<Query, TData, TVariables>,
  /**
   * Optional options to give the query hook
   */
  options?: QueryOptions<TData, TVariables>
) => [IState<TData>, UseQueryHelpers<Query, TData, TVariables>];

/**
 * Options of useQuery
 */
export interface QueryOptions<TData, TVariables extends IVariables>
  extends CommonHookOptions<TData, TVariables> {
  /**
   * Fetch policy used for the hook.
   *
   * If not specified, by default is "cache-first", but if **lazy**
   * is **true**, it's default is "cache-and-network"
   */
  fetchPolicy?: FetchPolicy;
  /**
   * Specify **lazy** behaviour of the query.
   *
   * Wait until explicit query call.
   */
  lazy?: boolean;
  /**
   * Activate and specify milliseconds polling interval of the hook call;
   */
  pollInterval?: number;
}

/**
 * **useQuery** constructor
 */
export const createUseQuery = <
  Query,
  Schema extends { Query: ObjectNode } = { Query: ObjectNode }
>(
  createOptions: CreateOptions<Schema>
): UseQuery<Query> => {
  const { endpoint, schema, creationHeaders } = createOptions;
  const useQuery: UseQuery<Query> = <TData, TVariables extends IVariables>(
    queryFn: QueryFn<Query, TData, TVariables>,
    options: QueryOptions<TData, TVariables> = defaultEmptyObject
  ) => {
    const optionsRef = useRef(options);
    const {
      lazy,
      pollInterval,
      variables,
      fetchPolicy,
      hookId,
    } = (optionsRef.current = defaultOptions(options));

    const serializedVariables = variables ? JSON.stringify(variables) : '';
    const variablesStrRef = useRef(serializedVariables);
    variablesStrRef.current = serializedVariables;
    const subscribeKeyObj = useRef<SubscriberHookFn>({
      variables: serializedVariables,
      fn: queryFn,
    });
    subscribeKeyObj.current.variables = serializedVariables;
    subscribeKeyObj.current.fn = queryFn;

    const isMountedRef = useRef(false);
    const isFetchingRef = useRef(false);

    const queryFnRef = useRef(queryFn);
    queryFnRef.current = queryFn;

    const [state, dispatch] = useReducer<IStateReducer<TData>>(
      StateReducer,
      StateReducerInitialState<TData>(lazy)
    );
    const stateRef = useRef(state);
    stateRef.current = state;

    console.log(207, {
      hookId,
      state,
    });
    const fetchQuery = useFetchCallback<TData, TVariables>({
      dispatch,
      endpoint,
      effects: {
        onPreEffect: () => {
          console.log(212222, {
            hookId,
          });
        },
        onErrorEffect: logDevErrors,
      },
      type: 'query',
      creationHeaders,
      optionsRef,
      stateRef,
    });

    const initialQueryClient = useMemo(() => {
      const client = new Client<Query>(schema.Query, fetchQuery);

      // client.cache.rootValue = SharedCache.initialCache(client.cache.rootValue);

      return client;
    }, [fetchQuery]);

    const queryClientRef = useRef<Client<Query>>(initialQueryClient);

    const queryCallback = useCallback<QueryCallback<TData, Query, TVariables>>(
      async (queryArgs = defaultEmptyObject) => {
        let {
          query = queryFnRef.current,
          fetchPolicy = optionsRef.current.fetchPolicy,
          variables: variablesArgs,
        } = queryArgs;

        optionsRef.current.fetchPolicy = fetchPolicy;

        const variables =
          variablesArgs ||
          optionsRef.current.variables ||
          (defaultEmptyObject as TVariables);

        let client: Client<Query> = queryClientRef.current;

        console.log({
          hookId,
          state: stateRef.current,
        });
        let dataValue: Maybe<TData> = null;

        let newClientCreated = false;

        let fetchPromise: Promise<void> | undefined;

        let noCache = false;

        console.log({
          hookId,
        });
        if (fetchPolicy === 'network-only' || fetchPolicy === 'no-cache') {
          noCache = true;
        } else {
          const cacheDataFound = SharedCache.cacheData.get(
            subscribeKeyObj.current.fn
          )?.[variablesStrRef.current];
          console.log({
            cacheDataFound,
            serializedVariables,
          });
          if (cacheDataFound) {
            dataValue = cacheDataFound;

            if (fetchPolicy === 'cache-and-network') {
              query(client.query, variables);
            }
          } else {
            dataValue = query(client.query, variables);
            console.log({
              dataValue,
              serializedVariables,
              hookId,
            });
          }
        }

        let isFetchingGqless = client.scheduler.commit.accessors.size !== 0;
        if (isFetchingGqless) {
          isFetchingRef.current = isFetchingGqless;
        }

        if (fetchPolicy === 'cache-only') {
          if (!isFetchingGqless) {
            isFetchingRef.current = false;
          }

          if (
            stateRef.current.fetchState === 'done' &&
            stringifyIfNeeded(stateRef.current.data) ===
              stringifyIfNeeded(dataValue)
          ) {
            console.log({
              hookId,
              dataValue,
            });
            return dataValue;
          }
          dispatch({
            type: 'done',
            payload: dataValue,
            stateRef,
          });

          return dataValue;
        }

        const waitForGqlessFetch = () =>
          new Promise<void>((resolve) => {
            const timeout = setTimeout(() => {
              isFetchingRef.current = false;

              resolve();
            }, optionsRef.current.fetchTimeout);

            client.scheduler.commit.onFetched.then(() => {
              isFetchingRef.current = false;
              clearTimeout(timeout);

              resolve();
            });
          });

        if (noCache || !isFetchingGqless) {
          if (fetchPolicy === 'cache-and-network') {
            if (
              stringifyIfNeeded(stateRef.current.data) !==
              stringifyIfNeeded(dataValue)
            ) {
              dispatch({
                type: 'setData',
                payload: dataValue,
                stateRef,
              });
            }
          }

          console.log(335, 'cachefound', {
            dataValue,
            serializedVariables,
            hookId,
          });

          if (
            fetchPolicy === 'no-cache' ||
            fetchPolicy === 'network-only' ||
            fetchPolicy === 'cache-and-network'
          ) {
            client = new Client<Query>(schema.Query, fetchQuery);
            newClientCreated = true;
            queryClientRef.current = client;

            query(client.query, variables);

            fetchPromise = waitForGqlessFetch();
          } else {
            console.log('362,', {
              fetchPolicy,
              hookId,
              serializedVariables,
              dataValue,
            });
          }
        } else if (isFetchingGqless) {
          fetchPromise = waitForGqlessFetch();
          console.log('371,', {
            fetchPolicy,
            hookId,
            serializedVariables,
            dataValue,
            fetchPromise,
          });
        } else {
          console.log('372,', {
            fetchPolicy,
            hookId,
            serializedVariables,
            dataValue,
          });
        }

        if (fetchPromise) {
          console.log('388!', { hookId });
          await fetchPromise;
          console.log('389!!!');
          dataValue = query(client.query, variables);
          console.log('390,', {
            fetchPolicy,
            hookId,
            serializedVariables,
            dataValue,
          });
        }

        console.log('afterpromise', {
          dataValue,
          serializedVariables,
          hookId,
        });

        dispatch({
          type: 'done',
          payload: dataValue,
          stateRef,
        });

        if (query.name && cacheSubscribeFn) {
          SharedCache.cacheSet(
            subscribeKeyObj.current,
            dataValue,
            cacheSubscribeFn
          );
        }

        return dataValue;
      },
      [fetchQuery]
    );

    const queryCallbackRef = useRef(queryCallback);
    queryCallbackRef.current = queryCallback;

    useEffect(() => {
      if (pollInterval > 0) {
        const interval = setInterval(async () => {
          if (
            !isFetchingRef.current && optionsRef.current.lazy
              ? stateRef.current.called
              : true
          ) {
            isFetchingRef.current = true;
            await queryCallbackRef
              .current({ fetchPolicy: 'network-only' })
              .catch(console.error);
            isFetchingRef.current = false;
          }
        }, pollInterval);

        return () => {
          clearInterval(interval);
        };
      }

      return;
    }, [pollInterval]);

    const isFirstMountRef = useRef(true);

    useEffect(() => {
      if (isFirstMountRef.current) {
        isMountedRef.current = true;
        isFirstMountRef.current = false;
      } else if (
        optionsRef.current.variables &&
        (optionsRef.current.lazy ? stateRef.current.called : true)
      ) {
        console.log(
          '467777777777777777777777777777777777777777777777777777777',
          {
            hookId,
          }
        );
        isFetchingRef.current = true;
        queryCallbackRef.current().catch(console.error);
      }
    }, [serializedVariables]);

    const helpers = useMemo<UseQueryHelpers<Query, TData, TVariables>>(() => {
      return {
        refetch: (args) => {
          return queryCallbackRef.current({
            variables: args?.variables,
            fetchPolicy: 'cache-and-network',
          });
        },
        cacheRefetch: (args) => {
          return queryCallbackRef.current({
            variables: args?.variables,
            fetchPolicy: 'cache-only',
          });
        },
        callback: queryCallbackRef.current,
        query: queryClientRef.current.query,
      };
    }, []);

    useEffect(() => {
      if (hookId) {
        return SharedCache.subscribeHookPool(hookId, {
          callback: async (args) => {
            const variables = args?.variables as TVariables | undefined;
            const fetchPolicy = args?.fetchPolicy;
            return (await queryCallbackRef.current({
              variables,
              fetchPolicy,
            })) as any;
          },
          refetch: async (args) => {
            const variables = args?.variables as TVariables | undefined;
            return (await queryCallbackRef.current({
              variables,
              fetchPolicy: 'cache-and-network',
            })) as any;
          },
          cacheRefetch: async (args) => {
            const variables = args?.variables as TVariables | undefined;
            return (await queryCallbackRef.current({
              variables,
              fetchPolicy: 'cache-only',
            })) as any;
          },
          state: stateRef,
        });
      }
      return;
    }, [hookId]);

    const queryFnName = queryFn.name;

    const cacheSubscribeFn = useMemo(() => {
      if (queryFnName) {
        const subscribeFn: CacheSubscribeFn = async (data) => {
          if (
            !isFetchingRef.current &&
            stringifyIfNeeded(data) !== stringifyIfNeeded(stateRef.current.data)
          ) {
            console.log('53333333336', {
              hookId,
              data,
            });
            dispatch({
              type: 'done',
              payload: data,
              stateRef,
            });
          }
        };
        return subscribeFn;
      }

      return;
    }, [queryFnName]);

    useEffect(() => {
      if (queryFnName && cacheSubscribeFn) {
        return SharedCache.subscribeCache(
          subscribeKeyObj.current,
          cacheSubscribeFn
        );
      }
      return;
    }, [queryFnName, cacheSubscribeFn]);

    const isStateDone = state.fetchState === 'done';

    console.log({
      serializedVariables,
      hookId,
    });
    if (!isMountedRef.current && !isFetchingRef.current && !lazy) {
      let foundCacheData: TData | undefined;
      isFetchingRef.current = true;

      switch (fetchPolicy) {
        case 'cache-and-network':
        case 'cache-first':
        case 'cache-only': {
          if (queryFnName) {
            console.log({
              cacheData: SharedCache.cacheData,
              serializedVariables,
              hookId,
            });
            foundCacheData = SharedCache.cacheData.get(
              subscribeKeyObj.current.fn
            )?.[serializedVariables];
            console.log({
              foundCacheData,
              serializedVariables,
              fnName: subscribeKeyObj.current.fn.name,
              hookId,
            });
            if (foundCacheData) {
              stateRef.current.data = foundCacheData;
              if (fetchPolicy === 'cache-and-network') {
                stateRef.current.fetchState = 'loading';
                dispatch({
                  type: 'setData',
                  payload: foundCacheData,
                  stateRef,
                });
              } else {
                console.log('588', {
                  hookId,
                  fetchPolicy,
                });
                stateRef.current.fetchState = 'done';
                dispatch({
                  type: 'done',
                  payload: foundCacheData,
                  stateRef,
                });
              }
            }
          }
          break;
        }
        default: {
        }
      }

      switch (fetchPolicy) {
        case 'cache-first':
        case 'cache-only': {
          if (!foundCacheData) {
            console.log('611', {
              hookId,
            });
            isFetchingRef.current = true;
            queryCallback()
              .catch((error) => {
                console.error(error);
              })
              .finally(() => {
                isFetchingRef.current = false;
              });
          }
          break;
        }
        default: {
          queryCallback().catch((error) => {
            console.error(error);
          });
        }
      }
    }

    useEffect(() => {
      if (isStateDone && optionsRef.current.onCompleted) {
        optionsRef.current.onCompleted(
          stateRef.current.data,
          SharedCache.hooksPool
        );
      }
    }, [isStateDone]);

    return useMemo(() => [state, helpers], [state, helpers]);
  };

  return useQuery;
};
