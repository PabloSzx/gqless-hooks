import { Client, ObjectNode, QueryFetcher } from 'gqless';
import { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';

import {
  CommonHookOptions,
  CreateOptions,
  defaultEmptyObject,
  FetchPolicy,
  Headers,
  IS_BROWSER,
  IState,
  IStateReducer,
  IVariables,
  lazyInitialState,
  logDevErrors,
  Maybe,
  SharedCache,
  StateReducer,
  stringifyIfNeeded,
  TIMEOUT_ERROR_MESSAGE,
  useFetchCallback,
  useSubscribeCache,
} from './common';

/**
 * Query function, it receives the query schema from
 * **gqless** and the variables, if any.
 *
 * It should return the **data** expected from the hook.
 */
type QueryFn<Query, TData, TVariables extends IVariables> = (
  /**
   * Schema generated by **gqless**
   */
  schema: Client<Query>['query'],
  /**
   * Optional variables to receive and use
   */
  variables: TVariables
) => TData;

/**
 * Query callback arguments
 */
interface QueryCallbackArgs<Query, TData, TVariables extends IVariables> {
  /**
   * Function override of the initial query schema function
   */
  query?: QueryFn<Query, TData, TVariables>;
  /**
   * fetchPolicy to override the policy given in the hook itself.
   */
  fetchPolicy?: FetchPolicy;
  /**
   * Variables to be used instead of the specified in the hook.
   */
  variables?: TVariables;
  /**
   * Whether it should dispatch to the hook the data results
   *
   * By default is true
   */
  shouldDispatchData?: boolean;
}

/**
 * Fully featured hook callback
 */
type QueryCallback<TData, Query, TVariables extends IVariables> = (
  queryArgs?: QueryCallbackArgs<Query, TData, TVariables>
) => Promise<Maybe<TData>>;

/**
 * Shorthand query callback args
 */
interface QueryQuickCallbackArgs<TVariables extends IVariables> {
  /**
   * Variables to specify if needed
   */
  variables?: TVariables;
}

/**
 * Shorthand hook callback, only **variables** to specify
 */
type QueryQuickCallback<TData, TVariables extends IVariables> = (
  queryArgs?: QueryQuickCallbackArgs<TVariables>
) => Promise<Maybe<TData>>;

const defaultOptions = <TData, TVariables extends IVariables>(
  options: QueryOptions<TData, TVariables, keyof gqlessSharedCache>
) => {
  const {
    lazy = false,
    fetchPolicy = options.lazy ? 'cache-and-network' : 'cache-first',
    fetchTimeout = 10000,
    pollInterval = 0,
    notifyOnNetworkStatusChange = true,
    skip = false,
    headers = defaultEmptyObject as Headers,
    ...rest
  } = options;
  return {
    lazy,
    fetchPolicy,
    fetchTimeout,
    pollInterval,
    notifyOnNetworkStatusChange,
    skip,
    headers,
    ...rest,
  };
};

/**
 * fetchMore pagination function
 *
 * You should specify a subset of the hooks variables
 * which will merge with the specified in the hook options
 * and a **updateQuery** function that should return the new data
 * hopefully merged with the previous data.
 *
 * It returns a promise of the resulting merged data and updates
 * the hook data
 */
type FetchMoreCallback<
  TData,
  TVariables extends IVariables
> = (fetchMoreOptions: {
  /**
   * Subset of the original variables of the query
   */
  variables: Partial<TVariables>;
  /**
   * Function that receives the previous data,
   * the result of the query just fetched.
   *
   * It should return the new data merged with the
   * previous data.
   */
  updateQuery: (
    /**
     * Previous hook data
     */
    previousResult: Maybe<TData>,
    /**
     * Resulting new data
     */
    fetchMoreResult: Maybe<TData>
  ) => Maybe<TData> | Promise<Maybe<TData>>;
  /**
   * Whether the hook should re-render when the network is calling fetchMore
   *
   * The default value is the same already used for **notifyOnNetworkStatusChange**
   */
  notifyLoading?: boolean;
}) => Promise<Maybe<TData>>;

/**
 * **useQuery** helpers returned from hook
 */
export interface UseQueryHelpers<Query, TData, TVariables extends IVariables> {
  /**
   * Query callback using **cache-and-network** fetchPolicy.
   */
  refetch: QueryQuickCallback<TData, TVariables>;
  /**
   * Generic query callback.
   */
  callback: QueryCallback<TData, Query, TVariables>;
  /**
   * Pagination query
   */
  fetchMore: FetchMoreCallback<TData, TVariables>;
}

/**
 * **useQuery** hook
 */
export type UseQuery<Query> = <
  TData,
  TVariables extends IVariables,
  CacheKey extends keyof gqlessSharedCache
>(
  /**
   * Query function, it should return the data expected from the mutation
   */
  queryFn: QueryFn<Query, TData, TVariables>,
  /**
   * Optional options to give the query hook
   */
  options?: QueryOptions<TData, TVariables, CacheKey>
) => [IState<TData>, UseQueryHelpers<Query, TData, TVariables>];

/**
 * Options of useQuery
 */
export interface QueryOptions<
  TData,
  TVariables extends IVariables,
  CacheKey extends keyof gqlessSharedCache
> extends CommonHookOptions<TData, TVariables> {
  /**
   * Fetch policy used for the query hook.
   *
   * If not specified, by default is "cache-first", but if **lazy**
   * is **true**, it's default is "cache-and-network"
   */
  fetchPolicy?: FetchPolicy;
  /**
   * Specify **lazy** behaviour of the query.
   *
   * Wait until explicit query call.
   *
   * _It also disables `sharedCacheId` behaviour_
   */
  lazy?: boolean;
  /**
   * Activate and specify milliseconds polling interval of the hook call;
   */
  pollInterval?: number;
  /**
   * Shared hook cache id
   *
   * In order to be able to sync different query hooks data
   * you can specify a shared cache id between those hooks which
   * will update each other data.
   *
   * This cache id also works as **in memory persistence** across different
   * hook instances of the same hook, across navigating through different pages for example.
   */
  sharedCacheId?: CacheKey;
  /**
   * Whether the hook should re-render when it's fetching after a refetch
   * and change it's **fetchState** to **_"loading"_**
   *
   * **By default it's set to true**
   */
  notifyOnNetworkStatusChange?: boolean;
  /**
   * Skip automatic query hook call if it's set to true
   *
   * This option only works if lazy is false or not specified
   */
  skip?: boolean;
}

/**
 * Prepare Query beforehand
 *
 * Useful for:
 * - Server side rendering
 * - Improved type-safety
 * - Prefetching queries, improving user experience
 *
 *
 * `Example in Next.js`
 * @example
 * ```ts
 * const HelloQuery = prepareQuery({
 *    cacheId: "helloWorld",
 *    query: (schema) => {
 *       return schema.hello({ arg: "world" });
 *    },
 * });
 *
 * interface HelloWorldProps {
 *    helloWorld: typeof HelloQuery.dataType
 * }
 *
 * export const getServerSideProps: GetServerSideProps<HelloWorldProps> =
 *  async () => {
 *    const helloWorld = await HelloQuery.prepare();
 *
 *    return {
 *        props: {
 *           helloWorld
 *        }
 *    }
 * };
 *
 * const HelloPage: NextPage<HelloWorldProps> = (props) => {
 *    HelloQuery.useHydrateCache(props.helloWorld);
 *
 *    const [{ data }] = HelloQuery.useQuery();
 *
 *    return <div>{JSON.stringify(data, null, 2)}</div>
 * }
 * ```
 */
type PrepareQuery<Query> = <
  TData,
  TVariables extends Record<string, unknown>,
  CacheKey extends keyof gqlessSharedCache
>({
  cacheId,
  query,
  headers: headersPrepare,
  variables: variablesPrepare,
  fetchTimeout: timeout,
}: {
  /**
   * Shared Cache Id used for memory persistance
   */
  cacheId: CacheKey;
  /**
   * Query function that returns the data from the accessors
   */
  query: QueryFn<Query, TData, TVariables>;
  /**
   * Optional add headers to the fetch query
   */
  headers?: Headers;
  /**
   * Variables for the query
   */
  variables?: TVariables;
  /**
   * Timeout in milliseconds for the fetch query, by default is 5000
   */
  fetchTimeout?: number;
}) => {
  /**
   * Prepare the query and returns a promise of the data
   */
  prepare: (prepareArgs?: {
    /**
     * Optional add headers to the fetch query
     *
     * _It merges with the `prepareQuery` **headers**_
     */
    headers?: Headers;
    /**
     * Variables for the query
     *
     * _It merges with the `prepareQuery` **variables**_
     */
    variables?: TVariables;
    /**
     * Check if the cache already has the data before
     * making the network request.
     *
     * By default it's **false**
     */
    checkCache?: boolean;
  }) => Promise<TData> | TData;
  /**
   * Gives back the query function.
   *
   * It should be used in the first parameter
   * of **useQuery**.
   */
  query: typeof query;
  /**
   * Gives back the cacheId.
   *
   * It should be used in the **sharedCacheID**
   * option in `useQuery`.
   */
  cacheId: typeof cacheId;
  /**
   * Hydrate the cache in the first mount, preventing network calls.
   */
  useHydrateCache: (data: TData) => void;
  /**
   * Shorthand useQuery hook, it only accepts the options
   */
  useQuery: (
    /**
     * Optional options to give the query hook
     *
     * These options will merge with the options given in "prepareQuery"
     */
    options?: QueryOptions<TData, TVariables, CacheKey>
  ) => [IState<TData>, UseQueryHelpers<Query, TData, TVariables>];
  /**
   * Returns only the data type expected from the query
   * function.
   *
   * It only works as a **TypeScript** helper, in runtime it's `undefined`,
   * therefore it should only be used with `typeof`.
   */
  dataType: TData;
};

/**
 * **useQuery** constructor
 */
export const createUseQuery = <
  Query,
  Schema extends { Query: ObjectNode } = { Query: ObjectNode }
>(
  createOptions: CreateOptions<Schema>
): {
  /**
   * useQuery hook
   */
  useQuery: UseQuery<Query>;
  /**
   * prepareQuery
   */
  prepareQuery: PrepareQuery<Query>;
} => {
  const {
    endpoint,
    schema,
    creationHeaders = defaultEmptyObject as Headers,
  } = createOptions;
  const useQuery: UseQuery<Query> = <TData, TVariables extends IVariables>(
    queryFn: QueryFn<Query, any, TVariables>,
    options: QueryOptions<any, TVariables, string | number> = defaultEmptyObject
  ) => {
    const optionsRef = useRef(options);
    const {
      lazy,
      pollInterval,
      variables,
      sharedCacheId,
      notifyOnNetworkStatusChange,
      skip,
    } = (optionsRef.current = defaultOptions(options));

    const isMountedRef = useRef(false);
    const isFetchingRef = useRef(false);

    const notifyOnNetworkStatusChangeRef = useRef(notifyOnNetworkStatusChange);
    notifyOnNetworkStatusChangeRef.current = notifyOnNetworkStatusChange;

    const queryFnRef = useRef(queryFn);
    queryFnRef.current = queryFn;

    const [state, dispatch] = useReducer<IStateReducer<TData>, IState<TData>>(
      StateReducer,
      undefined as any,
      lazyInitialState
    );

    const stateRef = useRef(state);
    stateRef.current = state;

    const isNotDismounted = useRef(true);
    useEffect(() => {
      return () => {
        isNotDismounted.current = false;
      };
    }, []);

    const fetchQuery = useFetchCallback<TData, TVariables>({
      dispatch,
      endpoint,
      effects: {
        onErrorEffect: logDevErrors,
      },
      type: 'query',
      creationHeaders,
      optionsRef,
      stateRef,
      notifyOnNetworkStatusChangeRef,
      isNotDismounted,
    });

    const initialQueryClient = useMemo(() => {
      const client = new Client<Query>(schema.Query, fetchQuery);

      return client;
    }, [fetchQuery]);

    const queryClientRef = useRef<Client<Query>>(initialQueryClient);

    const { foundCache, cacheSubscribeFn } = useSubscribeCache({
      sharedCacheId,
      dispatch,
      stateRef,
      optionsRef,
    });

    const queryCallback = useCallback<QueryCallback<TData, Query, TVariables>>(
      async (queryArgs = defaultEmptyObject) => {
        let {
          query = queryFnRef.current,
          fetchPolicy = optionsRef.current.fetchPolicy,
          variables: variablesArgs,
          shouldDispatchData = true,
        } = queryArgs;

        let firstTimeCallNotNotifyNetworkStatusChange = false;

        if (
          !stateRef.current.called &&
          optionsRef.current.notifyOnNetworkStatusChange === false
        ) {
          // If the query has not been called, and notifyOnNetworkStatusChange options is turned off,
          // it should notify loading anyways the first time
          firstTimeCallNotNotifyNetworkStatusChange = true;
          notifyOnNetworkStatusChangeRef.current = true;
        }

        try {
          optionsRef.current.fetchPolicy = fetchPolicy;

          const variables =
            variablesArgs ||
            optionsRef.current.variables ||
            (defaultEmptyObject as TVariables);

          let client: Client<Query> = queryClientRef.current;

          let dataValue: Maybe<TData> = null;

          let fetchPromise: Promise<void> | undefined;

          let noCache = false;

          let lazyCacheAndNetworkFoundCache = false;

          if (fetchPolicy === 'network-only' || fetchPolicy === 'no-cache') {
            noCache = true;
          } else {
            if (optionsRef.current.lazy && !stateRef.current.called) {
              // if this query is lazy, and it's first time called
              if (optionsRef.current.sharedCacheId) {
                const cacheData =
                  SharedCache.cacheData[optionsRef.current.sharedCacheId];
                if (cacheData) {
                  stateRef.current.data = cacheData;
                  stateRef.current.errors = undefined;
                  stateRef.current.called = true;
                  if (fetchPolicy === 'cache-and-network') {
                    lazyCacheAndNetworkFoundCache = true;
                    stateRef.current.fetchState = 'loading';
                  } else {
                    isFetchingRef.current = false;
                    stateRef.current.fetchState = 'done';

                    return cacheData;
                  }
                }
              }
            }

            dataValue = query(client.query, variables);
          }

          let isFetchingGqless = client.scheduler.commit.accessors.size !== 0;
          if (isFetchingGqless) {
            isFetchingRef.current = isFetchingGqless;
          }

          if (fetchPolicy === 'cache-only') {
            if (!isFetchingGqless) {
              isFetchingRef.current = false;
            }

            if (
              stateRef.current.fetchState === 'done' &&
              stringifyIfNeeded(stateRef.current.data) ===
                stringifyIfNeeded(dataValue)
            ) {
              return dataValue;
            }

            if (shouldDispatchData && isNotDismounted.current) {
              dispatch({
                type: 'done',
                payload: dataValue,
                stateRef,
              });
            }

            return dataValue;
          }

          const waitForGqlessFetch = () =>
            new Promise<void>((resolve, reject) => {
              const timeout = setTimeout(() => {
                isFetchingRef.current = false;

                reject(Error(TIMEOUT_ERROR_MESSAGE));
              }, optionsRef.current.fetchTimeout);

              client.scheduler.commit.onFetched.then(() => {
                isFetchingRef.current = false;
                clearTimeout(timeout);

                resolve();
              });
            });

          if (noCache || !isFetchingGqless) {
            if (
              fetchPolicy === 'cache-and-network' &&
              !lazyCacheAndNetworkFoundCache
            ) {
              if (
                shouldDispatchData &&
                isNotDismounted.current &&
                stringifyIfNeeded(stateRef.current.data) !==
                  stringifyIfNeeded(dataValue)
              ) {
                dispatch({
                  type: 'setData',
                  payload: dataValue,
                  stateRef,
                });
              }
            }

            if (
              fetchPolicy === 'no-cache' ||
              fetchPolicy === 'network-only' ||
              fetchPolicy === 'cache-and-network'
            ) {
              client = new Client<Query>(schema.Query, fetchQuery);
              queryClientRef.current = client;

              query(client.query, variables);

              fetchPromise = waitForGqlessFetch();
            }
          } else if (isFetchingGqless) {
            fetchPromise = waitForGqlessFetch();
          }

          if (fetchPromise) {
            await fetchPromise;
            dataValue = query(client.query, variables);
          }

          if (shouldDispatchData && isNotDismounted.current) {
            dispatch({
              type: 'done',
              payload: dataValue,
              stateRef,
            });

            if (optionsRef.current.sharedCacheId) {
              SharedCache.setCacheData(
                optionsRef.current.sharedCacheId,
                dataValue,
                cacheSubscribeFn
              );
            }
          }

          return dataValue;
        } finally {
          if (firstTimeCallNotNotifyNetworkStatusChange) {
            notifyOnNetworkStatusChangeRef.current = false;
          }
        }
      },
      [fetchQuery, cacheSubscribeFn]
    );

    const queryCallbackRef = useRef(queryCallback);
    queryCallbackRef.current = queryCallback;

    const isFirstMountRef = useRef(true);

    /**
     * Auto first hook call
     */
    if (
      IS_BROWSER &&
      !lazy &&
      !skip &&
      !foundCache &&
      !isMountedRef.current &&
      !isFetchingRef.current
    ) {
      state.fetchState = 'loading';
      state.called = true;
      isFetchingRef.current = true;

      queryCallback()
        .catch(console.error)
        .finally(() => {
          isFetchingRef.current = false;
        });
    }

    /**
     * Skip first call effect
     */
    useEffect(() => {
      if (
        !optionsRef.current.lazy &&
        !skip &&
        !stateRef.current.called &&
        !isFetchingRef.current
      ) {
        isFetchingRef.current = true;
        stateRef.current.called = true;
        queryCallbackRef
          .current()
          .catch(console.error)
          .finally(() => {
            isFetchingRef.current = false;
          });
      }
    }, [skip]);

    /**
     * Polling effect
     */
    useEffect(() => {
      if (pollInterval > 0) {
        const interval = setInterval(async () => {
          if (
            !optionsRef.current.skip &&
            !isFetchingRef.current &&
            optionsRef.current.lazy
              ? stateRef.current.called
              : true
          ) {
            isFetchingRef.current = true;
            await queryCallbackRef
              .current({ fetchPolicy: 'network-only' })
              .catch(console.error)
              .finally(() => {
                isFetchingRef.current = false;
              });
          }
        }, pollInterval);

        return () => {
          clearInterval(interval);
        };
      }

      return;
    }, [pollInterval]);

    const serializedVariables = variables ? JSON.stringify(variables) : '';

    /**
     * Variables on change refetch effect
     */
    useEffect(() => {
      if (isFirstMountRef.current) {
        isMountedRef.current = true;
        isFirstMountRef.current = false;
      } else if (
        optionsRef.current.variables &&
        (optionsRef.current.lazy ? stateRef.current.called : true) &&
        !skip &&
        !isFetchingRef.current
      ) {
        isFetchingRef.current = true;
        queryCallbackRef
          .current()
          .catch(console.error)
          .finally(() => {
            isFetchingRef.current = false;
          });
      }
    }, [serializedVariables, skip]);

    const variablesStringHistory = useRef<Set<string>>(undefined as never);
    if (variablesStringHistory.current === undefined) {
      variablesStringHistory.current = new Set();
    }

    const helpers = useMemo<UseQueryHelpers<Query, TData, TVariables>>(() => {
      return {
        fetchMore: async ({
          variables: partialVariables,
          updateQuery,
          notifyLoading,
        }) => {
          notifyLoading =
            notifyLoading ??
            optionsRef.current.notifyOnNetworkStatusChange ??
            true;

          let previousVariables = optionsRef.current.variables;

          if (previousVariables && variablesStringHistory.current.size === 0) {
            variablesStringHistory.current.add(
              JSON.stringify(previousVariables)
            );
          }

          const variables = previousVariables
            ? { ...previousVariables, ...partialVariables }
            : (partialVariables as TVariables);

          variablesStringHistory.current.add(JSON.stringify(variables));

          const previousNotifyStatus = notifyOnNetworkStatusChangeRef.current;
          if (previousNotifyStatus !== notifyLoading) {
            notifyOnNetworkStatusChangeRef.current = notifyLoading;
          }

          isFetchingRef.current = true;
          stateRef.current.called = true;
          const fetchMoreResult = await queryCallbackRef.current({
            variables,
            fetchPolicy: 'cache-first',
            shouldDispatchData: false,
          });
          isFetchingRef.current = false;

          if (previousNotifyStatus !== notifyLoading) {
            notifyOnNetworkStatusChangeRef.current = previousNotifyStatus;
          }

          const data = await updateQuery(
            stateRef.current.data,
            fetchMoreResult
          );

          if (
            stateRef.current.fetchState !== 'done' ||
            data !== stateRef.current.data
          ) {
            if (isNotDismounted.current)
              dispatch({
                type: 'done',
                payload: data,
                stateRef,
              });

            if (optionsRef.current.sharedCacheId) {
              SharedCache.setCacheData(
                optionsRef.current.sharedCacheId,
                data,
                cacheSubscribeFn
              );
            }
          }

          return data;
        },
        refetch: (args) => {
          return queryCallbackRef.current({
            variables: args?.variables,
            fetchPolicy: 'cache-and-network',
          });
        },

        callback: queryCallbackRef.current,
      };
    }, [cacheSubscribeFn]);

    const isStateDone = state.fetchState === 'done';

    /**
     * onCompleted hook event
     */
    useEffect(() => {
      if (isStateDone && optionsRef.current.onCompleted) {
        optionsRef.current.onCompleted(stateRef.current.data);
      }
    }, [isStateDone, stateRef.current.data]);

    return [state, helpers];
  };

  const prepareQuery: PrepareQuery<Query> = <
    TPrepareData,
    TVariables extends IVariables,
    CacheKey extends keyof gqlessSharedCache
  >({
    cacheId,
    query,
    headers: headersPrepare = defaultEmptyObject as Headers,
    variables: variablesPrepare = defaultEmptyObject as TVariables,
    fetchTimeout = 5000,
  }: {
    cacheId: CacheKey;
    query: QueryFn<Query, TPrepareData, TVariables>;
    headers?: Headers;
    variables?: TVariables;
    fetchTimeout?: number;
  }) => {
    const dataType: TPrepareData = (undefined as unknown) as TPrepareData;
    const useHydrateCache = (data: TPrepareData) => {
      const firstMountRef = useRef(true);

      if (firstMountRef.current) {
        firstMountRef.current = false;
        SharedCache.setCacheData(cacheId, data, null);
      }
    };

    const isFetching = { current: false };

    return {
      prepare: (prepareArgs = defaultEmptyObject) => {
        const {
          headers = defaultEmptyObject as Headers,
          variables = defaultEmptyObject as TVariables,
          checkCache = false,
        } = prepareArgs;

        if (checkCache) {
          const cacheData: TPrepareData = SharedCache.cacheData[cacheId];
          if (cacheData !== undefined) {
            return cacheData;
          }
        }

        return new Promise<TPrepareData>((resolve, reject) => {
          const fetchQuery: QueryFetcher = async (query, variables) => {
            isFetching.current = true;
            try {
              const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  Accept: 'application/json',
                  ...creationHeaders,
                  ...headersPrepare,
                  ...headers,
                },
                body: JSON.stringify({ query, variables }),
                mode: 'cors',
              });

              let json: any;
              try {
                json = await response.json();
              } catch (err) {}

              let error: any;
              if (!response.ok) {
                if (Array.isArray(json?.errors)) {
                  error = json.errors;
                } else {
                  error = Error(
                    `Network error, received status code ${response.status} ${response.statusText}`
                  );
                }
              } else if (json?.errors) {
                error = json.errors;
              }

              if (error) throw error;

              return json;
            } catch (err) {
              reject(err);
              throw err;
            } finally {
              isFetching.current = false;
            }
          };
          const client = new Client<Query>(schema.Query, fetchQuery);

          let variablesQuery = { ...variablesPrepare, ...variables };

          let data = query(client.query, variablesQuery);

          let isFetchingGqless = client.scheduler.commit.accessors.size !== 0;

          if (isFetchingGqless) {
            new Promise<void>((fetchResolve, fetchReject) => {
              const timeoutFetch = setTimeout(() => {
                const error = Error(TIMEOUT_ERROR_MESSAGE);
                fetchReject(error);
              }, fetchTimeout);

              client.scheduler.commit.onFetched.then(() => {
                clearTimeout(timeoutFetch);

                fetchResolve();
              });
            })
              .then(() => {
                data = query(client.query, variablesQuery);

                SharedCache.setCacheData(cacheId, data, null);

                resolve(data);
              })
              .catch(reject);
          }
        });
      },
      query,
      cacheId,
      dataType,
      useHydrateCache,
      useQuery: (
        queryOptions: QueryOptions<
          TPrepareData,
          TVariables,
          CacheKey
        > = defaultEmptyObject
      ) => {
        return useQuery<TPrepareData, TVariables, CacheKey>(query, {
          ...queryOptions,
          sharedCacheId: cacheId,
        });
      },
    };
  };

  return { useQuery, prepareQuery };
};
